---
title: "10.예외"
subtitle: "아이템69 ~ 아이템77"
permalink: /notes/effective-java/ch10
author_profile: true
date: 2021-03-30
categories:
  - 이펙티브 자바
tags:
  - java
last_modified_at: 2021-03-30
---

예외를 제대로 활용한다면 프로그램의 가독성, 신뢰성, 유지보수성이 높아지지만, 잘못 사용하면 반대의 효과만 나타난다.

## 아이템69 : 예외는 진짜 예외 상황에만 사용하라

> 예외는 예외 상황에서 쓸 의도로 설계 되었다. 정상적인 제어 흐름에서 사용해서는 안되며, 이를 프로그래머에게 강요하는 API를 만들어서도 안된다.

- 예외는 오직 예외 상황에서만 써야한다. 절대로 일상적인 제어 흐름용으로 쓰여서는 안된다.
- 잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야 한다.
특정 상태에서만 호출 할 수 있는 '상태 의존적' 메서드를 제공하는 클래스는 '상태 검사' 메서드도 함께 제공하여야 한다.

### 상태 검사 메서드, 옵셔널, 특정 값 중 하나를 선택하는 지침

1. 외부 동기화 없이 여러 스레드가 동시에 접근 할 수 있거나 외부요인으로 상태가 변할 수 있다면 옵셔널이나, 특정 값을 사용한다. (상태 검사 메서드와 상태 의존적 메서드 호출 사이에 객체의 상태가 변할 수 있기 때문)
2. 성능이 중요한 상황에서 상태 검사 메서드가 상태 의존적 메서드의 작업 일부를 중복 수행한다면 옵션널이나 특정 값을 선택한다.
3. 1,2번을 제외한 나머지 경우에는 상태 검사 메서드 방식이 조금 더 낫다.

## 아이템70 : 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라

> **복구 할 수 있는 상황이라면 검사예외를, 프로그래밍 오류라면 비검사 예외를 던지자. 확실하지 않다면 비검사 예외를 던지자.** 검사예외도 아니고 런타임 예외도 아닌 throwable은 정의하지도 말자. 검사 예외라면 복구에 필요한 정보를 알려주는 메서드도 제공하자.

### 자바가 문제 상황을 알리는 타입(throwable)

- 검사 예외
- 에러

### 검사예외 사용

**호출하는 쪽에서 복구하리라 여겨지는 상황이라면 검사 예외를 사용하라**

- 검사 예외를 던지면 호출자가 그 예외를 catch로 잡거나, 더 바깥으로 전파하도록 강제 한다.
즉 API 설계자가 API 사용자에게 검사 예외를 던져주어 그 상황에서 회복해내라고 요구하는 것이다.
- 검사 예외는 일반적으로 복구 할 수 있는 조건일 때 발생한다. 따러서 호출자가 예외 상황에서 벗어나는 데 필요한 정보를 알려주는 메서드를 함께 제공하는 것이 중요하다.

### 비검사 예외 사용

두 가지가 존재한다. 런타임 예외, 에러다.

- 프로그램에서 비검사 예외를 던졌다는 것은 복구가 불가능하거나 더 실행해봐야 득보다는 실이 많다는 뜻이다.
- 프로그래밍 오류를 나타낼 때는 런타임 예외를 사용하자.
- 일반적으로 구현하는 비검사 throwable은 모두 `RuntimeException`의 하위 클래스여야 한다.
- 예외의 메서드는 주로 그 예외를 일으킨 상황에 관한 정보를 코드 형태로 전달하는 데 쓰인다.
- 에러는 보통 JVM 자원부족, 불변식 깨짐 등 더 이상 수행을 계속 할 수없는 상황을 나타낼때 사용한다. 즉 Error 클래스를 상속해서 하위 클래스를 만드는 일은 자제해야 한다.

## 아이템71 : 필요 없는 검사 예외 사용은 피하라

> 꼭 필요한 곳에만 사용한다면 검사 예외는 프로그램의 안정성을 높여주지만, 남용하면 쓰기 고통스러운 API를 낳는다. **API 호출자가 예외 상황에서 복구할 방법이 없다면 비검사 예외를 던지자. 복구가 가능하고 호출자가 그 처리를 해주길 바란다면, 우선 옵셔널을 반환해도 될지 고민하자.** 옵셔널만으로 상황을 처리하기 충분한정보를 제공할 수 없을 경우 검사 예외를 던지자.

- 검사 예외는 발생한 문제를 프로그래머가 처리하여 안정을 높이게끔 해준다.
- 검사 예외를 과도하게 사용할 경우 사용하기 불편한 API가 된다.
- API를 제대로 사용해도 발생할 수 있는 예외거나, 프로그래머가 의미 있는 조치를 취할 수 있는 경우가 아니라면 비검사 예외를 사용하는 게 좋다.

### 검사 예외 회피 방법

1. 결과 타입을 담은 옵셔널 반환 (※ 예외 원인에 대한 이유에 대한 부가정보를 알 수 없음)
2. 검사 예외를 던지는 메서드를 2개로 쪼개 비검사 예외로 변경

## 아이템72 : 표준 예외를 사용하라

> 예외도 재사용하는 것이 좋으며, 자바 라이브러리는 대부분 API에서 쓰기에 충분한 수의 예외를 제공한다.

### IllegalArgumentException

가장 많이  사용되는 예외로 호출자가 인수로 부적절한 값을 넘길 때 던지는 예외

### IllegalStateException

대상 객체의 상태가 호출된 메서드를 수행하기에 적합하지 않을 때 던진다.

※  `null` 값을 허용하지 않는 메서드에 `null`을 건네면 `NullPointerException`을 던져야한다.

### ConcurrentModificationException

단일 스레드에서 사용하려고 설계한 객체를 여러 스레드가 동시에 수정하려 할 때 던진다.

### UnsupportedOperationException

클라이언트가 요청한 동작을 대상 객체가 지원하지 않을 때 던진다.

### 재사용하지 말아야한 클래스

- `Exception`
- `RuntimeException`
- `Throwable`
- `Error`

## 아이템73 : 추상화 수준에 맞는 예외를 던지라

> 아래 계층의 예외를 예방하거나 스스로 처리 할 수없고, 그 예외를 상위 계층에 그대로 노출하기 곤란하다면 예외 번역을 사용하라. 이 때 예외 연쇄를 이용하면 상위 계층에는 맥락에 얼울리는 고수준 예외를 던지면서 근본 원인도 함께 알려주어 오류를 분석하기 좋다.

### 예외 번역

메서드가 저수준 예외를 처리하지 않고 바깥으로 전파해 버릴 경우 수행하려는 일과 관련없는 에러가 발생 할 경우 상위 계층에서는 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꿔 던지는 방식이다.  그리고 예외를 번역 할 때, 저수준 예외가 디버깅에 도움이 된다면 **예외 연쇄**를 사용하는 게 좋다

```java
try {
	... // 저수준 추상화를 이용한다.
} catch (LowerLevelException cause) {
	throw new HigherLevelException(...);
}
```

### 예외 연쇄

문제의 근본 원인인 저수준 예외를 고수준 예외에 실어 보내는 방식이다.  이렇게 되면 별도의 접근자 메서드를 통해 언제든 저수준 예외를 꺼내 볼 수 있다.

```java
try {
	... // 저수준 추상화를 이용한다.
} catch (LowerLevelException cause) {
	throw new HigherLevelException(cause);
}
```

### 주의사항

- 무턱대고 예외를 전파하는 것보다야 예외 번역이 우수한 방법이지만, 그렇다고 남용해서는 안된다.
- 아래 계층에서 예외가 발생하지 않도록 하는 것이 최선이다.
- 차선책으로 아래 계층에서의 예외를 피할 수 없다면 상위 계층에서 그 예외를 조용히 처리하여 문제를 API 호출자에게 까지 전파하지 않게 한다. (이 경우 로깅을 활용하자)

## 아이템74 : 메서드가 던지는 모든 예외를 문서화하라

> 메서드가 던질 가능성이 있는 모든 예외를 문서화하라. 문서화 하지 않을 경우 다른사람이 그 클래스나 인터페이스를 효과적으로 사용하기 어렵가나 불가능할 수 있다.

- 검사 예외는 항상 따로따로 선언하고, 각 예외가 발생하는 상황을 자바독의 @throw 태그를 사용하여 정확히 문서화 하자.
- 공통 상위 클래스 하나로 뭉뜽그려 선언하는 일은 삼가자
⇒ Exception이나 Throwable을 던질 경우 사용자가 대처할 수 있는 힌트를 주지 못할 뿐더라 발생할 수 있는 다른 예외까지 삼켜버릴 수 있어 API 사용성을 크게 떨어뜨린다.
- 메서드가 던질 수 있는 예외를 각각 @throw 태그로 문서화하되, 비검사 예외는 메서드 선언의 throws 목록에 넣지 말자
- 한 클래스에 정의된 많은 메서드가 같은 이유로 같은 예외를 던진다면 그 예외를 클래스 설명에 추가하는 방법도 있다.

## 아이템75 : 예외의 상세 메시지에 실패 관련 정보를 담으라

> 사후 분석을 위해 실패 순간의 상황을 정확히 포착해 예외의 상세 메시지에 담아야 한다.

기본적으로 예외를 잡지 못해 프로그램이 실패하면 자바 시스템은 그 예외의 스택 추적 정보를 자동으로 출력한다. 스택 추적은 예외 객체의 `toString` 메서드를 호출해 얻는 문자열이다. 
(이 정보가 실패 원인을 제공하는 유일한 정보인 경우가 많다.)

- 실패 순간을 포착하려면 발생한 예외에 관여된 모든 매개변수와 필드의 값을 실패 메시지에 담아야 한다.
- 보안과 관련한 정보는 주의해서 다뤄야한다. 상태 메시지에 비밀번호나 암호 키 같은 정보까지 담아선 안된다.
- 예외의 상세 메시지와 최종 사용자에게 보여줄 오류 메시지를 혼동해서는 안된다.
최종 사용자에게는 친절한 안내 메시지를 보여줘야하는 반면, 예외 메시지는 가독성보단 담긴 내용이 훨씬 중요하다.
- 예외는 실패와 관련한 정보를 얻을 수 있는 접근자 메서드를 적절히 제공하는 것이 좋다.

## 아이템76 : 가능한 한 실패를 원자적으로 만들라

> 메서드를 실패 원자적으로 만들면 예외가 발생하여도 그 객체는 여전히 정상적으로 사용할 수 있다.

### 실패 원자적

호출된 메서드가  실패 하더라도 해당 객체는 호출 전 상태를 유지하는 특성

### 메서드를 실패 원자적으로 만드는 방법

1. 불변 객체로 설계
2. 작업 수행에 앞서 매개변수의 유효성 검사
3. 객체의 임시 복사본에서 작업을 수행한 다음, 작업이 성공적으로 완료되면 원래 객체와 교체하는 것이다.
4. 작업 도중에 발생하는 실패를 가로채는 복구 코드를 작성하여 작업 전 상태로 되돌린다.
(자주 쓰이는 방법은 아니다)

### 비고

- 실패 원자성은 일반적으로 권장되지만, 항상 달성 할 수 있는 것은 아니다. 
ex) 두 스레드가 동기화 없이 같은 객체를 동시에 수정하는 경우
- 실패 원자적으로 만들 수 있더라도 이를 위해 비용이나 복잡도가 클 수도 있다.

## 아이템77 : 예외를 무시하지 말라

> API 설계자가 메서드 선언에 예외를 명시하는 까닭은, 그 메서드를 사용할 때 적절한 조치를 취해달라고 말하는 것이다. 무시하지 말자.

예외는 문제 상황에 잘 대처하기 위해 존재하는데 catch 블록을 비워두면 예외가 존재할 이유가 없어진다.

```java
try {
	...
} catch (SomeException e) {
	// 여기를 단순이 비워두면 위에서 발생한 예외가 무시된다.
}
```

### 예외를 무시 할 경우

예외를 무시해야하는 경우도 있다.  예를 들어 FileInputStream을 닫을 경우이다. 이 경우는 입력 전용스트림이므로 파일의 상태를 변경하지 않았니 복구할 것이 없으며, 스트림을 닫는다는 것은 필요한 정보는 이미 다 읽었다는 뜻이다.

**예외를 무시하기로 했다면 catch 블록 안에 그렇게 결정한 이유를 주석으로 남기고 예외 변수 이름도 ignored로 바꿔 놓도록 하자**

```java
int numColor = 4; // 기본값. 어떤 지도라도 이 값이면 충분하다.
try {
	numColors = f.get(1L, TimeUnit.SECONDS);
} catch (TimeoutException | ExecuteionException ignored) {
	// 기본값을 사용한다(색상 수를 최소화하면 좋지만, 필수는 아니다)
}
```