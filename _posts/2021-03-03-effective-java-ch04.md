---
title: "04. 클래스와 인터페이스"
subtitle: "아이템15 ~ 아이템25"
permalink: /notes/effective-java/ch04
author_profile: true
date: 2021-03-03 23:38
categories:
  - 이펙티브 자바
tags:
  - java
last_modified_at: 2021-03-03 23:38
---
## 아이템15 : 클래스와 멤버의 접근 권한을 최소화 하라

> 프로그램 요소의 접근성은 가능한 한 최소한으로 하라. 꼭 필요한 것만 골라 최소한의 public API를 설계하자. 그 외에는 클래스, 인터페이스, 멤버가 의도치 않게 API로 공개 되는 일이 없도록 해야 한다. **public 클래스는 상수용 public static final 필드 외에는 어떠한 public 필드도 가져서는 안 된다.** public static final 필드가 참조하는 객체가 불변인지 확인하라.

- 정보은닉

    시스템을 모듈 단위로 분해하기 위한 기본 원리로 시스템에서 자주 변경되는 부분을 상대적으로 덜 변경되는 인터페이스 뒤로 감추가 하는 모듈 분할 원리.
    - 오브젝트 : 코드로 이해하는 객체지향 설계 참조 -

### 정보은닉의 장점

- 여러 컴포넌트를 병렬로 개발 할 수 있기 때문에 **시스템 개발 속도를 높인다.**
- 각 컴포넌트를 만들었기 때문에 파악이 쉽고 빨라 디버깅이 용이하고, 결과적으로 **시스템 관리비용을 낮춘다.**
- 다른 컴포넌트에 영향을 주지 않고 특정 컴포넌트만 최적화 가능하다. 즉 성능최적화에 도움을 준다. (간접적으로)
- 소프트웨어 재사용을 높인다.
- 큰 시스템의 제작 난이도를 낮춰준다.

### 접근제한자

**접근제한자를 활용하는 기본원칙은 모든 클래스와 멤버의 접근성을 최대한 좁혀야 한다.**

private < package-private < protected < public (접근범위 순)

- `public`클래스의 인스턴스 필드는 되도록 `public`이 아니어야 한다.
(`public`으로 선언시 그 필드에 담을 수 있는 값을 제한할 힘을 잃게 된다.)
- `public` 가변 필드를 갖는 클래스는 일반적으로 thread-safe 하지 않다.
- 길이가 0이 아닌 배열은 모두 변경 가능하다.
⇒ 클래스에서 **public static final** **배열** 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안된다.

    ```java
    // 보안 허점이 숨어 있다.
    public static final Thing[] VALUES = {...}

    // 공통 변경 사항
    private static final Thing[] PRIVATE_VALUES = {...}

    // 방법1
    public static final List<Thing> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));

    // 방법2
    public static final List<Thing> values() {
    	return PRIVATE_VALUES.clone();
    }
    ```

## 아이템16 : public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라.

> public 클래스는 절대 가변 필드를 직접 노출해서는 안된다.
불변 필드라면 노출해도 덜 위험하지만, 안심할 수 는 없다.

```java
class Point {
    private double x;
    private double y;

    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }

    public double getX() { return x;}
    public double getY() { return y; }
		public void setX(double x) { this.x = x; }
    public void setY(double y) { this.y = y; }
}
```

- 패키지 바깥에서 접근 할 수 있는 클래스라면 접근자를 제공함으로써 클래스 내부 표현 방식을 언제든 바꿀 수 있는 유연성을 얻을 수 있다.
- package-private 클래스 혹은 private 중첩 클래스라면 데이터 필드를 노출한다 해도 하등의 문제가 없다.

## 아이템17 : 변경 가능성을 최소하라.

> 1. 클래스는 꼭 필요한 경우가 아니면 불변이어야 한다. (getter가 있다고 해서 무조건 setter를 만들지 말자)
2. 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소화 시키자
3. 다른 합당한 이유가 없다면 모든 필드는 private final이어야 한다.
4. 생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.

### 불변 클래스

그 인스턴스의 내부 값을 수정할 수 없는 클래스
가변 클래스보다 설계하고 구현하기 쉬우며, 오류가 생길 여지가 적고 안전하다.
ex) String, 기본 타입의 박싱된 클래스(Integer, Double, Character 등등),  BigInteger, BigDecimal

### 불변클래스를 만들기 위한 5가지 규칙

1. 객체의 상태를 변경하는 메서드를 제공하지 않는다.
2. 클래스를 확장 할 수 없도록 한다. (상속 X)
3. 모든 필드를 final로 선언한다.
4. 모든 필드를 private으로 선언한다.
5. 자기 외에는 내부의 가변 컴포넌트에 접근 할 수 없도록 한다.

함수형 프로그래밍으로 프로그래밍 하면 코드에서 불변이 되는 영역의 비율이 높아지는 장점을 가지고 있다.

### 불변객체의 장점

1. 단순하다. (생성 시점의 상태를 파괴 될 때까지 그대로 간직한다.)
2. Thread-Safe 
3. 공유가 가능하다. (불변 객체끼리는 내부 데이터를 공유 할 수 있다.)
4. 그 자체로 실패 원자성을 제공한다.
(실패 원자성이란 '메서드에서 예외가 발생한 후에도 그 객체는 여전히 유효한 상태이다'는 성질이다. )

### 불편객체 단점

값이 다르면 독립된 객체로 만들어야 한다.

### 자신을 상속하게 못하는 방법

모든 생성석자를 `private` 또는 `package-private`으로 만들고 `public` 정적 팩터리를 제공한다.

```java
public class Complex {
    private final double re;
    private final double im;

    private Complex(double re, double im) {
        this.re = re;
        this.im = im;
    }

    public static Complex valueOf(double re, double im) {
        return new Complex(re, im);
    }
}
```

## 아이템18 : 상속보다는 컴포지션을 사용하라

> 상속은 강력하지만 캡슐화를 해치는 문제가 있다. 상위 클래스와 하위 클래스가 순수한 IS-A 관계일 때만 써야한다.
상속의 취약점을 피하려면 컴포지션과 포워딩을 사용하자.

**※ 책에서의 상속은 클래스가 다른 클래스를 확장하는 구현상속을 뜻한다.** 
(클래스가 인터페이스를 구현하거나 인터페이스가 다른 인터페이스를 확장하는 인터페이스 상속이 아니다.)

### 메서드 호출과 달리 상속은 캡술화를 깨뜨린다.

### 컴포지션

- **기존 클래스가 새로운 클래스의 구성요소로 쓰인다**는 뜻에서 이러한 설계를 컴포지션이라고 한다.
- 기존 클래스의 대응하는 메서드를 호출하여 결과를 반환한다. (=이러한 전달 방식을 포워딩이라고 한다)
- 새 클래스의 메서드들을 전달 메서드라고 부른다.

### (구현)상속 사용 조건

- 상속은 반드시 하위 클래스가 상위 클래스의 '진짜' 하위타입 상황에서만 쓰여야 한다.
⇒ 클래스 B가 클래스 A와 is-a 관계 일때만 사용해야한다.
- 상속은 상위 클래스의 API를 '그 결함까지도' 그대로 승계한다.

## 아이템19 : 상속을 고려해 설계하고 문서화하라. 그러지 않다면 상속을 금지하라.

> 상속용 클래스를 설계하기란 만만치 않다. 클래스 내부에서 어떻게 사용하는지 모두 문서로 남겨야 하며, 문화화된 내용은 반드시 지켜져야한다.
클래스를 확장해야 할 명확한 이유가 없다면 상속을 금지하는 편이 낫다.
상속을 금지하려면 클래스를 fianl로 선언하던가, 생성자 모두를 외부에서 접근할 수 없게 만든다.

### 상속을 고려한 설계와 문서화란?

상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다. 

### 하위 클래스를 큰 어려움 없이 만들 수 있게 하려면?

- 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook )을 잘 선별하여 protected 메서드 형태로 공개해야 할 수 있다.
- 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야한다.
- 상속용 클래스의 생성자는 재정의 가능 메서드를 호출해서는 안된다. 
단 `private`, `final`, `static`메서드는 재정의가 불가능하기 때문에 생성자에서 안심하고 호출해도 된다.
- Cloneable과 Serializable 인터페이스는 상속용 설계의 어려움을 한층 더해준다.
clone과 readObject 에서도 재정의 가능 메서드를 호출해서는 안된다.

### 상속을 금지하는 방법

1. 클래스를 final로 선언한다
2. 모든 생성자를 private이나 package-private으로 선언하고 public 정적 팩터리를 만들어 준다.

## 아이템20 : 추상클래스보다는 인터페이스를 우선하라

> 일반적으로 다중 구현용 타입으로는 인터페이스가 적합하다. 복잡한 인터페이스라면 구현하는 수고를 덜어주는 골격 구현을 제공하는 방법을 고려해보자.

자바는 단일 상속만 지원하니, 추상 클래스 방식은 새로운 타입을 정의 하는데 큰 제약을 안게 되는 셈이다. 반면 인터페이스가 선언한 메서드를 모두 정의하고 그 일반 규약을 잘 지킨 클래스라면 다른 어떤 클래스를 상속했든 같은 타입으로 취급된다. 기존 클래스에도 손쉽게 새로운 인터페이스를 구현해넣을 수 있다.

### 믹스인

믹스인이란 클래스가 구현할 수 있는 타입으로, 믹스인을 구현한 클래스에 원래 '주된 타입' 외에도 특정 선택적 행위를 제공한다고 선언하는 효과를 준다. 즉 주된 기능에 선택적 기능을 혼합한다고 해서 믹스인이다.

- 인터페이스는 믹스인 정의에 안성맞춤이다.
- 인터페이스로는 계층구조가 없는 타입 프레임워크를 만들 수 있다.

### 인터페이스의 메서드의 구현방법

1. 디폴트 메서드
※ 본인이 수정할 수 있는 인터페이스에만 기본 메소드를 제공할 수 있다. 
⇒ equals, hashcode, toString 같은 Object 메서드들은 디폴트 메서드로 제공할 수 없다.
2. 인터페이스 + 추상 골격 구현 클래스 (=템플릿 메서드 패턴)
※ 골격 구현은 기본적으로 상속해서 사용하는 걸 가정하므로 **"아이템19 : 상속을 고려해 설계하고 문서화하라. 그러지 않다면 상속을 금지하라."** 를 지켜야 한다.
⇒ (추상클래스를 구현 하지 않은) 단순 구현을 활용하라. 

## 아이템21 : 인터페이스는 구현하는 쪽을 생각해 설계하라.

자바8 전에는 기존 구현체를 깨뜨리지 않고는 인터페이스에서 메서드를 추가할 방법이 없었다.
자바8에서는 기존 인터페이스에 메서드를 추가할 수 있게 **디폴트 메서드**가 생겼다.

### 디폴트 메서드 주의사항

- 디폴트 메서드가 모든 구현체들과 매끄럽게 연동 될거라는 보장은 없다.
- 디폴트 메서드가 컴파일에 성공하더라도 기존 구현체에 런타임 오류를 일으 킬 수 있다.
- 인터페이스를 설계 할 때는 여전히 세심한 주의를 기울여야 한다.

## 아이템22 : 인터페이스는 타입을 정의하는 용도로만 사용하라

> 인터페이스는 타입을 정의하는 용도로만 사용해야한다. 상수 공개용 수단으로 사용해서는 안된다.

**인터페이스는 자신을 구현한 클래스의 인스턴스를 참조 할 수 있는 타입 역할을 한다.** 달리 말해, 클래스가 어떤 인터페이스를 구현한다는 것은 자신의 인스턴스로 무엇을 할 수 있을지를 클라이언트에게 애기해주는 것이다.

### 상수 인터페이스 안티패턴은 인터페이스를 잘못 사용한 예이다.

```java
public interface PhysicalConstants {
	static final double AVOGADROS_NUMBER = 6.002...
}
```

- 사용자에게는 의미가 없다. 오히려 혼란만 가중시킨다.
- 클라이언트 코드가 내부 구현에 이용하게 된다면 이후에 쓰지 않더라도 호환성 때문에 계속 해당 인터페이스를 구현하고 있어야 한다.

### 상수를 공개할 목적일 경우

- 해당 클래스나 인터페이스 자체에 추가해야한다.
ex)  `Integer.MAX_VALUE`, `Integer.MIN_VALUE`
- 열거 타입
- 유틸리티 클래스 활용

## 아이템23 : 태그 달린 클래스보다는 클래스 계층 구조를 활용하라

> 태그 달린 클래스를 써야 하는 상황은 거의 없다. 태그 필드가 등장한다면 태그를 없애고 계층 구조로 대체하는 방법을 생각해 보자.

### 태그 달린 클래스

*장황하고, 오류를 내기 쉽고, 비효율적이다.*

```java
class Figure {
    enum Shape { RECTANGLE, CIRCLE };

    final Shape shape; // 태그 필드 - 현재 모양을 나타낸다.

    // 다음 필드들은 모양이 사각형(RECTANGLE)일 때만 쓰인다.
    double length;
    double width;

    // 다음 필드느 모양이 원(CIRCLE)일 때만 쓰인다.
    double radius;

    // 원용 생성자
    Figure(double radius) {
        shape = Shape.CIRCLE;
        this.radius = radius;
    }

    // 사각형용 생성자
    Figure(double length, double width) {
        shape = Shape.RECTANGLE;
        this.length = length;
        this.width = width;
    }

    double area() {
        switch(shape) {
            case RECTANGLE:
                return length * width;
            case CIRCLE:
                return Math.PI * (radius * radius);
            default:
                throw new AssertionError(shape);
        }
    }
}
```

- 열거 타입 선언, 태그 필드, switch문 등 쓸데없는 코드가 많다.
- 여러 구현이 한 클래스에 혼재되어 있어 가독성이 나쁘다.
- 필드들을 final로 선언하려면 해당 의미에 쓰이지 않는 필드들 까지도 생성자에서 초기화 시켜야 한다.

### 클래스 계층구조

```java
abstract class Figure {
    abstract double area();
}

class Circle extends Figure {
    final double radius;
    Circle(double radius) { this.radius = radius; }
    @Override double area() { return Math.PI * (radius * radius); }
}

class Rectangle extends Figure {
    final double length;
    final double width;
    Rectangle(double length, double width) {
        this.length = length;
        this.width = width;
    }
    @Override double area() { return length * width; }
}
```

- 각 의미를 독립된 클래스에 담아 관련 없던 데이터 필드를 모두 제거
- 각 클래스의 생성자가 모든 필드를 남김없이 초기화하고 추상 메서드를 모두 구현했는지 컴파일러가 확인해준다.
- root 클래스(=Figure)를 건드리지 않고도 계층구조를 확장하고 사용할 수 있다.

## 아이템24 : 멤버 클래스는 되도록 static으로 만들라

> **중첩 클래스**에는 네 가지가 있으며, 각각의 쓰임이 다르다. 메서드 밖에서도 사용해야 하거나 메서드 안에 정의하기엔 너무 길다면 **멤버 클래스**로 만든다. 멤버 클래스의 인스턴스 가각이 바깥 인스턴스를 참조한다면 **비정적**으로, 그렇지 않으면 **정적**으로 만들다. 중첩 클래스가 한 메서드 안에서만 쓰이면서 그 인스턴스를 생성하는 지점이 단 한 곳이고 해당 타입으로 쓰기에 적합한 클래스나 인터페이스가 이미 있다면 **익명클래스**, 그렇지 않다면 **지역 클래스**로 만들자.

### 중첩클래스

- 다른 클래스 안에 정의된 클래스
- 자신을 감싼 바깥 클래스에서만 쓰여야 한다.
- 종류로는 다음 4가지가 있다.
정적 멤버 클래스, (비정적) 멤버 클래스, 익명 클래스, 지역 클래스

### 정적 멤버 클래스

- 다른 클래스 안에 선언되고, 바깥 클래스의 private 멤버에도 접근할 수 있다는 점만 제외하고는 일반 클래스와 동일하다.
ex) `Calculator.Operation.PLUS`, `Calculator.Operation.MINUS`

### (비정적)멤버 클래스

- `static` 이없고, 비정적 멤버 클래스의 인스턴스는 바깥 클래스의 인스턴스와 암묵적으로 연결된다. `this` 를 사용해 바깥 인스턴스의 메서드를 호출하거나 참조를 가져 올 수 있다.
- 개념상 중첩클래스의 인스턴스가 바깥 인스턴스와 독립적으로 존재 할 수 있다면 정적 멤버 클래스로 만들어야 한다. 비정적 멤버 클래스는 바깥 인스턴스 없이는 생성할 수 없다.
- 멤버 클래스에서 바깥 인스턴스에 접근 할 일이 없다면 무조건 `static`을 붙여서 정적 멤버 클래스로 만들자.
- 멤버 클래스가 공개된 클래스의 public이나 protected 멤버라면 정적이냐 아니냐는 두 배로 중요해진다. ⇒ 멤버 클래스 역시 공개 API가 되니, 이후 릴리즈에서 static을 붙이면 호환성이 깨진다.

### 익명클래스

- 익명클래스는 멤버 클래스와 달리, 쓰이는 시점에 선언과 동시에 인스턴스가 만들어진다.
- 익명클래스는 오직  비정적인 문맥에서 사용될 때만 바깥 클래스의 인스턴스를 참조할 수 있다.
- 주로 정적 팩터리 메서드를 구현할 때 사용한다.
- 자바8부터는 람다로 대체가능하다.

### 지역클래스

- 지역 클래슨는 지역변수를 선언할 수 있는 곳이면 실질적으로 어디서든 선언 할 수있고, 유효 범위도 지역 변수와 같다.
- 이름이 있고 반복해서 사용 할 수 있다.
- 정적 멤버를 가질 수 없으며, 가독성을 위해 짧게 작성되어야 한다.

## 아이템25 : 톱레벨 클래스는 한 파일에 하나만 담으라.

> 소스 파일  하나에는 반드시 톱레벨 클래스(혹은 인터페이스)를 하나만 담자.

**소소 파일 하나에 톱레벨 클래스를 여러 개 선언하더라도 자바 컴파일러에서는 컴파일에러가 발생하지 않지만 이는 아무런 득이 없을 뿐더러 심각한 위험을 감수해야하는 행위다. 즉 컴파일은 문제 없지만 컴파일러가 소스파일을 컴파일 하는 순서에 따라 런타임 시 동작이 달라 질 수 있다**