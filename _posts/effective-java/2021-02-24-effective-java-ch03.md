---
title: "03.모든 객체의 공통 메서드"
subtitle: "아이템10 ~ 아이템14"
permalink: /notes/effective-java/ch03
author_profile: true
date: 2021-02-24 18:15
categories:
  - 이펙티브 자바
tags:
  - java
last_modified_at: 2021-03-03 23:40
---

## 아이템10 : equals는 일반규약을 지켜 재정의 하라

> 꼭 필요한 경우가 아니면 equals를 재정의 하지말자. 대다수의 경우는 Object의 equals 선에서 끝난다. 재정의 를 해야할 경우에는 반드시 다섯 가지의 규약을 확실히 지켜야 한다.

### Equals 메서드 규칙

equals 메서드는 동치관계를 구현하며, 다음을 만족한다.
(동치관계 : 집합을 서로 같은 원소들로 이뤄진 부분집합으로 나누는 연산이다)

- **반사성**
    - 객체는 자기 자신과 같아야한다
    - x에 대해, x.equals(x)는 `true`이다
- **대칭성**
    - 두 객체는 서로에 대한 동치 여부에 똑같이 답해야 한다.
    - x, y에 대해, x.equals(y) `true`이면 y.equals(x)도 `true`이다.
- **추이성**
    - 첫 번째 객체와 두 번째 객체가 같고, 두 번째 객체와 세 번째 객체가 같다면, 첫 번째 객체와 세 번째 객체도 같아야 한다.
    - x, y, z에 대해, x.equals(y) `true`이고 y.equals(z)도 `true` 이면 x.equals(z)도 `true` 이다.
- **일관성**
    - 두 객체가 같다면 (어느 하나 혹은 두 객체 모두가 수정되지 않는 한) 계속 같아야 한다.
    - 클래스가 불변이든 가변이든 equlas의 판단에 신뢰할 수 없는 자원이 끼어들게 해서는 안된다.
    - x,y에 대해 x.equals(y)를 반복해서 호출하면 항상 `true`를 반환하거나 항상 `false`를 반환한다.
- **null-아님**
    - x에 대해 x.equals(null)은 항상 `false` 이다.
    - null 체크 시 명시적으로 null을 체크하는 것이 아니라 instanceof를 사용한 묵시적 검사가 낫다.

※ 모든 값은 null이 아닌 모든 참조 값이다.

### 양질의 Equals 메서드 구현 방법

1. == 연산자를 사용해 입력이 자기 자신의 참조인지 확인한다.
2. instanceof 연산자로 입력이 올바른 타입인지 확인한다.
3. 입력을 올바른 타입으로 형변환한다. (2번에서 성공하면 이 단계도 100% 성공)
4. 입력객체와 자기 자신의 대응되는 '핵심' 필드들이 모두 일치하는 하나씩 검사한다.

### 주의사항

- equals를 재정의 할땐 hashCode도 반드시 재정의 하자
- 너무 복잡하게 해결하려 들지 말자.
- Object 외의 타입을 매개변수로 받는 equals 메서드는 선언하지 말자.

## 아이템11 : equals를 재정의하려거든 hashcode도 재정의하라

> quals를 재정의한 클래스 모두에서 hashcode도 재정의해야 한다. 그렇지 않을 경우 HashMap, HashSet과 같은 컬렉션의 원소로 사용할 때 문제가 된다.
재정의한 hashcode는 Object의 API 문서에 기술된 일반 규약을 따라야 하며, 서로 다른 인스턴스라면 되도록 해시코드도 서로 다르게 구현해야한다.

### 리스코프 치환 원칙
어떤 타입에 있어 중요한 속성이면 그 하위 타입에서도 마찬가지로 중요하다.
따라서 그 타입의 모든 메서드가 하위 타입에서도 똑같이 잘 동작하여야한다.

### 주의사항

- 성능을 높인답시고 해시코드를 계산할 때 핵심 필드를 생략해서는 안된다.
- hashCode가 반환하는 값의 생성 규칙을 API 사용자에게 자세히 공표하지 말자.

## 아이템12 : toString을 항상 재정의하라

> 모든 구체 클래스에서 Object의 toString을 재정의하자. toString은 해당 객체에 관한 명확하고 유용한 정보를 읽기 좋은 형태로 반환해야 한다.

- toString의 일반 규약에 따르면 '간결하면서 사람이 읽기 쉬운 형태의 유익한 정보'를 반환해야 한다.
- toString을 잘 구현한 클래스는 사용하기에 훨씬 즐겁고, 그 클래스를 사용한 **시스템은 디버깅하기 쉽다.**
- 실전에서 toString은 그 객체가 가진 주요 정보 모두를 반환하는 게 좋다.
- toString의 반환값으로 포맷을 사용하든 안하든 의도가 명확해야한다.

## 아이템13 : clone 재정의는 주의해서 진행하라

> Cloneable이 몰고 온 모든 문제를 되짚어 봤을 때, 새로운 인터페이스를 만들 때는 절대 Cloneable을 확장해서는 안되며, 새로운 클래스도 이를 구현해서는 안된다.

- clone 메서드는 사실상 생성자와 같은 효과를 낸다. 즉, clone은 원본 객체에 아무런 해를 끼치지 않는 동시에 복제된 객체의 불변식을 보장해야한다.

## 아이템14 : Comparable을 구현할지 고려하라

> 순서를 고려해야 하는 값 클래스를 작성한다면 꼭 Comparable 인터페이스를 구현하여, 그 인스턴스들을 쉽게 정렬하고, 검색하고, 비교 기능을 제공하는 컬렉션과 어우러지도록 하여야 한다. 
필드의 값을 비교할 때 <, > 연산자 대신 박싱된 기본 타입 클래스가 제공하는 compare 메서드나 Comparator 인터페이스가 제공하는 비교자 생성 메서드를 이용한다.

### CompareTo

- 단순 동치성 비교에 뿐만 아니라 순서까지 비교 할 수 있다.
- 제네릭하다.

### CompareTo 규약

1. 두 객체의 참조의 순서를 바꿔 비교해도 예상한 결과가 나와야 한다.
2. 첫 번째가 두 번째보다 크고 두 번째가 세 번째보다 크면, 첫 번째는 세 번째보다 커야한다.
3. 크기가 같은 객체들끼리는 어떤 객체와 비교하더라도 항상 같아야 한다.

⇒ equlas 제약사항과 동일

### 기타

- 타입 비교 관련하여 자바7 부터는 박싱된 기본 타입 클래스들에 새로 추가된 정적 메서드인 compare를 이용하면 된다. 
ex1) Short.compare(a, b)
ex2) Integer.compare(a, b)
※ 관계 연산자를 사용하는 방식은 거추장스럽고 오류를 유발시킬 수 있다.
- 자바8 에서는 메서드 연쇄 방식으로 비교자를 생성 할 수 있게 되었다.