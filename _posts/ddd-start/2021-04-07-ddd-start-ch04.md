---
title: "04.리포지터리와 모델구현(JPA중심)"
subtitle: "리포지터리와 모델구현"
permalink: /notes/ddd-start/ch04
date: 2021-04-07 11:30
categories:
  - DDD START
tags:
  - java
last_modified_at: 2021-04-07 11:30
---

## JPA를 이용한 리포지터리 구현

- 애그리거트를 어떤 저장소에 저장하느냐에 따라 리포지터리를 구현하는 방법이 다르다.
- 데이터 보관소로 RDBMS를 사용할 때 객체 기반의 도메인 모델과 관계형 데이터 모델간의 매핑을 처리하는 기술로 ORM 만한것이 없다.

### 모듈 위치

가능하면 리포지터리 구현 클래스를 인프라스트럭처 영역에 위치시켜서 인프라스트럭처에 대한 의존을 낮춰야 한다.

## 매핑 구현

### 엔티티와 밸류 기본 매핑 구현

애그리거트와 JPA 매핑을 위한 기본 규칙은 다음과 같다

- 애그리거트 루트는 엔티티이므로 `@Entity`로 매핑 설정한다.
- 한 테이블에 엔티티와 밸류 데이터가 같이 있다면,
    - 밸류는 `@Embeddable`로 설정한다.
    - 밸류 타입 프로퍼티는 `@Embedded`로 매핑 설정한다.

### 기본생성자

JPA는 기술적 제약으로 기본생성자가 필요하다. 
다른 코드에서 사용하지 못하도록 `protected`로 선언하자.

### 필드 접근 방식 사용

- 엔티티에 프로퍼티를 위한 set/get 메서드를 추가하면 도메인의 의도가 사라진다.
- set 메서드 대신 의도가 잘드러나는 기능을 제공해야한다.

### 밸류 컬렉션을 `@Entitiy`로 매핑하기

JPA는 `@Embeddable` 타입의 클래스 상속 매핑을 지원하지 않는다. 따라서 상속 구조를 갖는 밸류 타입을 사용하려면 `@Entity`를 사용하여 처리해야한다.

## 애그리거트 로딩 전략

JPA 매핑을 설정할 때 항상 기억해야 할 점은 애그리거트에 속한 객체가 모두 모여야 완전한 하나가 된다는 것이다. 즉, 다음과 같이 애그리거트 루트를 로딩하면 루트에 속한 모든 객체가 완전한 상태여야 함을 의미한다. 완전해야하는 이유는 첫 번째 상태를 변경하는 기능을 실행 할 때 애그리거트 상태가 완전해야하고, 두번째는 표현 영역에서 애그리거트의 상태 정보를 보여줄 때 필요하기 때문이다.  

```java
// Product는 완전한 하나여야 한다.
Product product = productRepository.findById(id);
```

- 즉시 로딩 방식으로 설정하면 애그리거트 루트를 로딩하는 시점에서 속한 모든 객체를 함께 로딩할 수 있는 장점이 있지만, 컬렉션 관련하여 문제가 될 수 있다.
- 애그리거트는 개념적으로 하나여야 한다. 하지만, 루트 엔티티를 로딩하는 시점에 애그리거트에 속한 객체를 모두 로딩해야하는 것은아니다.

## 애그리거트 영속성 전파

애그리거트가 완전한 상태여야 한다는 것은 애그리거트 루트를 조회할 뿐만 아니라 저장하고 삭제 할때도 하나로 처리해야 함을 의미한다.

## 식별자 생성 기능

식별자는 크게 세 가지 방식 중하나로 생성한다.

- 사용자가 직접 생성
- 로메인 로직으로 생성
- DB를 이용한 일련번호 사용