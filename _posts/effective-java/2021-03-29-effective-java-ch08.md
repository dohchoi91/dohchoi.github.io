---
title: "08.메서드"
subtitle: "아이템49 ~ 아이템56"
permalink: /notes/effective-java/ch08
author_profile: true
date: 2021-03-29
categories:
  - 이펙티브 자바
tags:
  - java
last_modified_at: 2021-03-29
---

## 아이템49 : 매개변수가 유효한지 검사하라

> 메서드나 생성자를 작성할 때면 그 매개변수들에 어떤 제약이 있을지 생각해야한다. 그 제약들은 문서화하고 메서드 코드 시작 부분에서 명시적으로 검사해야한다.

- **메서드와 생성자 대부분은 입력 매개변수의 값이 특정 조건을 만족하기를 바란다.**

### 매개변수 검사를 제대로 하지 못하면 발생하는 문제

**매개변수 검사에 실패하면 실패 원자성을 어기는 결과를 낳을 수 있다.**

1. 메서드가 수행되는 중간에 모호한 예외를 던지며 실패 할 수 있다.
2. 메서드가 잘 수행되지만, 잘못된 결과를 반환 할 수 있다.
3. 메서드는 잘 수행 됬지만, 어떤 객체를 이상한 상태로 만들어놓아 미래의 알 수 없는 시점에 메서드와 관련없는 오류를 발생 시킬 수 있다.

### 매개변수 유효성 검사를 위한 방법

- `public`과 `protected`메서드는 매개변수 값이 잘못 됐을 때 던지는 예외를 문서화 해야한다.
⇒ API 사용자가 제약을 지킬 가능성을 크게 높일 수 있다.
- 자바7에 추가된 `java.util.Objects.requireNonNull` 메서드는 더 이상 null 검사를 수동으로 하지 않아도 된다.

    ```java
    this.streategy = Objects.requireNonNull(streategy, "전략");
    ```

- `public`이 아닌 메서드에서는 `assert`를 이용하여 유효성을 검증 할 수 있다.
- 메서드가 직접 사용하지는 않으나 나중에 쓰기 위해 저장하는 매개변수는 특히 더 신경써서 검사해야한다.

### 매개변수 유효성 검사 예외

1. 유효성 검사 비용이 지나치게 높거나, 실용적이지 않을 때
2. 계산 과정에서 암묵적으로 검사가 수행될 때

## 아이템50 : 적시에 방어적 복사본을 만들라

> 클래스가 클라이언트로부터 받는 혹은 클라이언트로 반환하는 구성요소가 가변이라면 그 요소는 반드시 방어적으로 복사해야한다. 복사 비용이 너무 크거나 클라이언트가 그 요소를 잘못 수정할 일이 없음을 신뢰한다면 방어적 복사를 수행하는 대신 해당 구성요소를 수정했을 때의 책임이 클라이언트에 있음을 문서에 명시하도록 하자.

- 자바는 C/C++에서 발생되는 메모리 충돌 오류에서 안전하다.
자바로 작성한 클래스는 시스템의 다른 부분에서 무슨 짓을 하든 그 불변식이 지켜지기 때문이다.
- 아무리 자바라 해도 다른 클래스로부터의 침범을 막을 수 있는 것은 아니다.
⇒ 클라이언트가 불변식을 깨뜨리려고 한다고 가정하고 방어적 프로그래밍을 하여야 한다.

### 방어적 복사

- 외부 공격으로부터 내부를 보호하려면 생성자에서 받은 가변 매개변수 각각을 방어적으로 복사해야한다.

    ```java
    // 기간을 표현하는 클래스 : 방어적 복사본 없는 버전
    public final class Period {
    	private final Date start;
    	private final Date end;
    	public Period(Date start, Date end) {
    		if (start.compareTo(end) > 0) {
    			throw new IllegalArgumentException("에러");
    		} 
    		this.start = start;
    		this.end= end;
    	}
    }
    // 기간을 표현하는 클래스 : 방어적 복사본
    public final class Period {
    	private final Date start;
    	private final Date end;
    	public Period(Date start, Date end) {
    		this.start = new Date(start.getTime());
    		this.end= new Date(end.getTime());

    		if (start.compareTo(end) > 0) {
    			throw new IllegalArgumentException("에러");
    		} 
    	}
    }

    //Period 인스턴스 내부를 공격
    Date start = new Date();
    Date end = new Date();
    Period p = new Period(start, end);
    end.setYear(79); // p의 내부를 수정했다.
    ```

- 매개변수가 제 3자에 의해 확장될 수 있는 타입이라면 방어적 복사본을 만들 때 `clone`을 사용해서는 안된다.
- 접근자 메서드를 이용하여 가변정보를 변경 시 가변 필드의 방어적 복사본을 반환하면 된다.

    ```java
    public final class Period {
    	private final Date start;
    	private final Date end;

    	// ... 생략 ... 

    	public Date start() {
    		return new Date(start.getTime());
    	}
    	public Date end() {
    		return new Date(end.getTime());
    	}
    }
    ```

- 생성자와 달리 접근자 메서드에서는 방어적 복사에 `clone`을 사용해도 되지만, 인스턴스를 복사하는데 일반적으로 생성자나 정적팩터리를 쓰는게 좋다.
- 메서드든 생성자든 클라이언트가 제공한 객체의 참조를 내부의 자료구조에 보관해야 할 때면 항시 그 객체가 클래스로 넘겨진 뒤 임의로 변경되어도 문제없이 동작할 지를 따져라. 확신이 없다면 복사본을 만들어 저장해야한다.

## 아이템51 : 메서드 시그니처를 신중히 설계하라

> API 설계 요령들을 잘 활용하면 배우기 쉽고, 쓰기 위며, 오류 가능성이 적은 API를 만들 수 있다.

### API 설계 요령

1. 메서드 이름을 신중히 짓자
    - 같은 패키지에[ 속한 다른 이름들과 일관되게 짓는게 좋다
    - 널리 받으들여지는 이름을 사용한다
    - 긴 이름을 피한다
    - 자바라이브러리 API가이드를 참조하면 도움이 된다.
2. 편의 메서드를 너무 많이 만들지 말자.
3. 매개변수 목록은 짧개 유지하자. (4개 이하가 좋다) 

    ※ 같은 타입의 매개변수 여러 개가 나오는 경우는 해롭다.

4. 긴 매개변수 목록을 짧게 줄이기이기 위해서는 여러 메서드로 쪼갠다.
5. 긴 매개변수 목록을 짧게 줄이기이기 위해서는 매개변수 여러 개를 묶어주는 도우미 클래스를 만들기.
6. 긴 매개변수 목록을 짧게 줄이기이기 위해서는 빌더 패턴을 응용하여 메서드 호출에 사용한다.
7. 매개변수 설정 할 때 매개변수의 타입으로는 클래스보다는 인터페이스가 더 낫다.
8. 매개변수 설정 할 때 `boolean` 보다는 원소 2개짜리 열거 타입이 낫다.

## 아이템52 : 다중정의(Overloading, 오버로딩)는 신중히 사용하라

> **프로그래밍 언어가 다중정의를 허용한다고 해서 다중정의를 꼭 활용하란 뜻은 아니다. 일반적으로 매개변수 수가 같을 때는 다중정의를 피하는게 좋다.** 상황에 따라, 특히 생성자라면 이 조언을 따르기가 불가능할 수 있다. 그럴 때는 헷갈릴 만한 매개변수는 형변환하여 정확한 다중정의 메서드가 선택되도록 해야한다. 이것이 불가능하면, 예컨데 기존 클래스를 수정해 새로운 인터페이스를 구현할 때는 같은 객체를 입력받는 다중정의 메서드들이 모두 동일하게 동작하도록 만들어야 한다. 그렇지 못하면 프로그래머들은 다중정의된 메서드나 생성자를 효과적으로 사용하지 못할 것이고, 의도대로 동작하지 않는 이유를 이해하지도 못할 것이다.

- 다중정의(overloading)의 메서드는 어느 메서드를 호출할지는 컴파일 시점에 정해진다.
- 오버라이딩된 메서드는 동적으로 선택되고, 오버로딩된 메서드는 정적으로 선택된다. (동적바인딩, 정적바인딩)
- 안전하고 보수적으로 가려면 매개변수 수가 같은 다중정의(overloading)는 만들지 말자
- 메서드를 다중정의할 때, 서로 다른 함수형 인터페이스라도 같은 위치의 인수로 받아서는 안된다.

## 아이템53 : 가변인수는 신중히 사용하라

> 인수 개수가 일정하지 않은 메서드를 정의해야 한다면 가변인수가 반드시 필요하다. 메서드를 정의할 때 필수 매개변수는 가변인수 앞에두고, 가변인수를 사용할 때는 성능 문제까지 고려하자.

### 가변인수

- 명시한 타입의 인수를 0개 이상 받을 수 있다.
- 가변인수 메서드를 호출하면, 먼저 인수의 개수와 길이가 같은 배열을 만들고 인수들을 이 배열에 저장하여 메서드에 전달한다.
- 성능에 민감한 상황이라면 가변인수는 걸림돌이 될 수 있다.
(메서드들을 호출 할 때마다 가변인수를 담는 배열을 만들기 때문이다.)
- `EnumSet` 의 정적 팩터리도 이 기법을 사용해 열거 타입 집합 생성 비용을 최소한다.

## 아이템54 : null이 아닌, 빈 컬렉션이나 배열을 반환하라

> null이 아닌, 빈 배열이나 컬렉션을 반환하라. null을 반환하는 API는 사용하기 어렵고 오류 처리 코드도 늘어난다. 그렇다고 성능이 좋은 것도 아니다.

### 빈컨테이너 대신 null을 리턴해야하는 주장이 틀린 이유

1. 성능저하 : 성능 분석 결과, 차이가 미비하다
2. 빈 컬렉션과 배열은 굳이 새로 할당하지 않고도 반환 할 수있다.

    ```java
    // 빈 컬렉션을 반환하는 예
    public List<Cheese> getCheeses() {
    	return cheesesInStock.isEmpty() ? 
    		Collections.emptyList() : new ArrayList<>(cheesesInStock);
    }
    ```

    ```java
    // 빈 배열을 반환하는 예
    private static final Cheese[] EMPTY_CHEESE_ARRAY = new Cheese[0];
    public Cheese[] getCheeses() {
    	return cheesesInStock.toArray(EMPTY_CHEESE_ARRAY);
    }
    ```

## 아이템55 : 옵셔널 반환은 신중히 하라

> 값을 반환하지 못할 가능성이 있고, 호출할 때마다 반환값이 없을 가능성을 염두에 둬야하는 메서드라면 옵셔널을 반환해야 할 상황 일 수 있다. 하지만 옵셔널 반환은 성능 저하가 뒤따르니, 성능에 민감한 메서드면 null을 반환하거나 예외를 던지는 편이 나을 수 있다.

### 자바8 이전에 메서드가 특정 조건에서 값을 반환할 수 없을 때 취할수 있는 선택지

1. 예외를 던진다
⇒ 스택트레이스의 비용이 크기 때문에 진짜 예외적인 상황에만 사용해야 한다.
2. `null`을 반환
⇒ `null` 처리 코드 추가. 그렇지 않을경우 `NullPointerException` 발생

### Optional<T>

- 원소를 최대 1개 가질 수 있는 **'불변'** 컬렉션이다.
- `null` 이 아닌 `T` 타입 참조를 하거나, 혹은 아무것도 담지 않을 수 있다.
- 옵셔널을 선택하는 이유는 검사 예외와 취지가 비슷하다.
⇒ 반환값이 없을 수 있음을 API 사용자에게 명확히 알려준다.

### 옵셔널 활용

1. 기본값을 정해둘 수 있다.

    ```java
    String lastWordInLexicon = max(words).orElse("단어없음");
    ```

2. 원하는 예외를 던질 수 있다.

    ```java
    Toy myToy = max(toys).orElseThrow(TemperTantrumException::new);
    ```

3. 항상 값이 채워져 있다고 가정한다.

    ```java
    Element lastNobleGas = max(Elements.NOBLE_GASES).get();
    ```

### 옵셔널 사용 시 주의 사항.

- 옵셔널을 반환하는 메서드에서는 절대 `null`을 반환하지 말자.
- 컬렉션, 스트림, 배열, 옵셔널 같은 컨테이너 타입은 옵셔널로 감싸면 안 된다.
- 박싱된 기본타입을 담은 옵셔널을 반환하는 일은 없도록 하자.
`OptionalInt`, `OptionalLong`, `OptionalDouble`을 사용하자
- 옵셔널을 컬렉션의 키, 값, 원소나 배열의 원소로 사용하는게 적절한 상황은 거의 없다.
- 옵셔널을 인스턴스 필드에 저장해두는 방법은 많은 상황에서 적절하지 않다.

## 아이템56 : 공개된 API 요소에는 항상 문서화 주석을 작성하라

> 문서화 주석은 API를 문서화하는 가장 훌륭하고 효과적인 방법이다. 공개 API라면 빠짐없이 설명을 달아야 한다. 표준규약을 일관되게 지키자. 문서화 주석에 임의의 HTML태그를 사용할 수 있음을 기억하라. 단, HTML 메타문자는 특별하게 취급해야 한다.

### 자바독(Javadoc)

소스파일에서 문서화 주석이라는 특수한 형태로 기술된 설명을 추려 API 문서로 변환해준다.

### 문서화

- API를 올바로 문서화하려면 공개된 모든 클래스, 인터페이스, 메서드, 필드 선언에 문서화 주석을 달아야한다.
- 메서드용 문서화 주석에는 해당 메서드와 클라이언트 사이의 규약을 명료하게 기술해야 한다.
상속용으로 설계된 클래스의 메서드가 아니라면 무엇을 하는지를 기술해야 한다. (How가 아니라 What을 기술)
- 전제조건과 사후조건뿐만 아니라 부작용도 문서화해야 한다.
여기서 부작용이란 사후조건으로 명확히 나타나지는 않지만 시스템의 상태에 어떠한 변화를 가져오는 것을 뜻한다.
- 메서드 계약을 완벽히 기술하려면 모든 매개변수에 `@Param` 태그를, 반환 타입이 void가 아니라면 `@return` 태그를, 발생할 가능성이 있는 모든 예외에는 `@throw` 태그를 달아야 한다.
- 클래스를 상속용으로 설계할 때는 자기사용 패턴에 대해서도 문서에 남겨 다른 프로그래메에게 그 메서드를 올바로 재정의하는 방법을 알려줘야 한다.
자바8에서는 `@impleSpec` 태그를 사용한다.
- API 설명에 <,>, & 등의 html 메타문자를 포함시키려면 특별처리 해야한다. `{@literal}` 태그로 감싼다.
- 메서드와 생성자의 요약 설명은 해당 메서드와 생성자의 동작을 설명하는 (주어가 없는) 동사구여야 한다.
- 제네릭 타입이나 제네릭 메서드를 문서화 할때는 모든 타입 매개변수에 주석을 달아야 한다.
- 열거 타입을 문서화할 때는 상수들에도 주석을 달아야 한다.
- 애너테이션 타입을 문서화할 때는 멤버들에도 모두 주석을 달아야 한다.