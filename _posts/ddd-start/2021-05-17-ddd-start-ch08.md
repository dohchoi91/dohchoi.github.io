---
title: "08.애그리거트 트랜잭션 관리"
subtitle: "애그리거트 트랜잭션 관리"
permalink: /notes/ddd-start/ch08
date: 2021-05-17 11:50
categories:
  - DDD START
tags:
  - java
last_modified_at: 2021-05-17 11:50
---

## 애그리거트와 트랜잭션
![image8-1.png](/assets/images/posts/ddd-start/image8-1.png)

애그리거트의 일관성이 깨지는 것을 방지하기 위해 다음 두 가지 중 하나를 해야한다.

1. 운영자가 배송지 정보를 조회하고 상태를 변경하는 동안 고객이 애그리거트를 수정하지 못하게 막는다.
2. 운영자가 배송지 정보 조회한 이후에 고객이 정보를 변경하면 운영자가 애그리거트를 다시 조회한 뒤 수정하도록 한다.

**트랜잭션은 다음 두 가지 방법으로 처리 될 수 있습니다.**

1. 선점 잠금(Pessimistic Lock)
2. 비선점 잠금(Optimistic Lock)

## 선점 잠금
선점 잠금은 먼저 애그리거트를 구한 스레드가 애그리거트 사용이 끝날 때까지 다른 스레드가 해당 애그리거트를 수정하는 것을 막는 방식이다.
![image8-2.png](/assets/images/posts/ddd-start/image8-2.png)

- JPA는 다음과 같이 구현하여 선점 잠금 방식을 적용할 수 있다.

    ```java
    Order order= entityManager.find(Order.class, orderNo, **LockModeType.PESSIMISTIC_WRITE**)
    ```

### 선점 잠금과 교착상태
선점 잠금 기능을 사용할 때는 잠금 순서에 따른 교착 상태가 발생하지 않도록 주의해야 한다.
선점 잠금에 따른 교착 상태는 상대적으로 사용자 수가 많을 때 발생할 가능성이 높고, 사용자 수가 많아지면 교착 상태에 빠지는 스레드가 더 빠르게 증가하게 된다.

**이런 문제를 방지하기 위해 잠금을 구할 때 최대 대기 시간을 지정해야 한다.**

- DBMS에 따라 교착 상태에 빠진 커넥션을 처리하는 방식이 다르다. 따라서, JPA를 활용한 선점 잠금을 사용하려면 사용하는 DBMS에 대해 JPA가 어떤 식으로 대기시간을 처리하는 지 반드시 확인해야한다.

## 비선점 잠금
선점 잠금이 강력해 보이긴 하지만 선점 잠금으로 모든 트랜잭션 충돌 문제가 해결되는 것은 아니다.**비선점 잠금 방식은 잠금을 해서 동시에 접근하는 것을 막는 대신 변경한 데이터를 실제 DBMS에 반영하는 시점에 변경 가능 여부를 확인하는 방식이다.** 비선점 잠금을 구현하려면 애그리거트에 버전으로 사용할 숫자 타입의 프로퍼티를 추가해야한다.
![image8-3.png](/assets/images/posts/ddd-start/image8-3.png)

- JPA는 버전(`@Version`)을 이용한 비선점 잠금 기능을 지원한다.

    ```java
    @Entity
    @Table(name = "purchase_order")
    @Access(AccessType.FIELD)
    publuc class Order {
    	@EmbeddedId
    	private OrderNo number;
    	@Version
    	private long version;
    }
    ```

### 강제 버전 증가
애그리거트에 애글거트 루트 외에 다른 엔티티가 존재하는데 기능 실행 도중 루트가 아닌 다른 엔티티의 값만 변경되었을 때 JPA는 루트 엔티티의 버전을 증가시키지 않는다.
이러한 JPA 특징은 애그리거트 관점에서 보면 문제가 된다. 논리적으로 애그리거트 구성요소 중 일부 값이 바뀌면 해당 애그리거트는 바뀐 것이다. **즉 애그리거트 내에 어떤 구송요소의 상태가 바뀌면 루트 애그리거트의 버전 값을 증가해야 비선점 잠금이 올바르게 동작한다.** 

- JPA에서는 강제로 버전 값을 증가시키는 잠금 모드를 지원한다.
`LockModeType.OPTIMISTIC_FORCE_INCREMENT`

## 오프라인 선점 잠금
단일 트랜잭션에서 동시 변경을 막는 선점 잠금 방식과 달리 **오프라인 선점 잠금은 여러 트랜잭션에 걸쳐 동시 변경을 막는다.** 첫 번째 트랜잭션을 시작할 때 오프라인 잠금을 선점하고, 마지막 트랜잭션에서 잠금을 해제한다. 잠금을 해제하기 전까지 다른 사용자는 잠금을 구할 수 없다.

오프라인 선점 잠금은 크게 다음 4가지 기능을 제공해야한다.

- 잠금 선점 시도
- 잠금 확인
- 잠금 해제
- 락 유효 시간 연장

**다음 두 가지 방법으로 구현 가능하다.**
1. 오프라인 선점 잠금의 기능을 가진 인터페이스, 클래스를 만들어 활용
2. DB를 이용하여 잠금 정보를 저장할 테이블과 인덱스를 만들어서 활용