---
title: "03.애그리거트"
subtitle: "애그리거트"
permalink: /notes/ddd-start/ch03
author_profile: true
date: 2021-04-06 13:50
categories:
  - DDD START
tags:
  - java
last_modified_at: 2021-04-06 13:50
---

# 애그리거트
![image3-3.png](/assets/images/posts/ddd-start/image3-3.png)
- 복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들려면 상위 수준에서 모델을 조망할 수 있는 방법이다.
- 관련된 객체를 하나의 군으로 묶어준다.
- 모델을 이해하는 도움을 줄 뿐만 아니라 일관성을 관리하는 기준이 된다.
- 각 애그리거트는 자기 자신을 관리할 뿐 다른 애그리거트를 관리하지 않는다.

# 애그리거트 루트

- 애그리거트에 속한 모든 객체가일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체
- 애그리거트 루트는 애그리거트 대표 엔티티로 애그리거트에 속한 객체는 애글거트 루트에 직접 또는 간접적으로 속한다.
- 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는 것이다.

## 도메인 규칙과 일관성

불필요한 중복을 피하고 애그리거트 루트를 통해서만 도메인 로직을 구현하게 만들려면 다음 두 가지를 습관적으로 적용해야 한다.

- 단순히 필드를 변경하는 set메서드를 public 범위로 만들지 않는다
- 밸류 타입은 불변으로 구현한다.

## 트랜잭션 범위

- 트랜잭션 범위는 작을수록 좋다.
- 한 트랜잭션에서는 한 개의 애그리거트만 수정해야 한다.
한 트랜잭션에서 두 개 이상의 애그리거트를 수정하면 트랜잭션 충돌이 발생할 가능성이 더 높다.
- 한 트랜잭션에서 두 개 이상의 애그리거트를 수정해야 한다면 직접 수정하지 말고 응용 서비스에서 두 애그리거트를 수정하도록 구현해야 한다.
- **예외 사항**
    - 팀표준 : 팀이나 조직의 표준에 따라 사용자 유스케이스와 관련된 응용서비스의 기능을 한 트랜잭션으로 실행해야하는 경우
    - 기술 제약 : 한 트랜잭션에서 두 개 이상의 애그리거트를 수정하는 대신 도메인 이벤트와 비동기를 사용하는 방식을 사용하는데, 기술적으로 이벤트 방식을 도입 할 수 없는 경우
    - UI 구현의 편리 : 운영자의 편리함을 위해 주문 목록 화면에서 여러 주문의 상태를 한번에 변경 할 경우

# 리포지터리와 애그리거트

- 애그리거트는 개념상 완전한 한 개의 도메인 모델을 표현하므로 객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재한다.
- 애그리거트는 개념적으로 하나이므로 리포지터리는 애그리거트 전체를 저장소에 영속화 해야한다.

# ID를 이용한 애그리거트 참조

한 객체가 다른 객체를 참조하는 것처럼 애그리거트도 다른 애그리거트를 참조한다. 애그리거트의 관리 주체가 애그리거트 루트이므로 애그럭트에서 다른 애그리거트를 참조하는다는 것은 애그리거트의 루트를 참조한다는 것과 같다.

## 필드를 이용한 애그리거트 참조 시 야기될 문제

1. **편한 탐색 오용** : 한 애그리거트 내부에서 다른 애그리거트 객체에 접근 할 수 있으며, 다른 애그리거트 상태를 쉽게 변경할 수 있다. ⇒ 애그리거트의 관리 범위는 자기자신으로 한정해야한다.
2. **성능에 대한 고민** :  JPA의 경우 지연로딩, 즉지 로딩
3. **확장 어려움** : ****서비스가 확장이 되면서 도메인별 시스템이 분리되는데, 애그리거트 루트를 참조하기 위해 단일 기술을 사용할 수 없음을 의미한다.

*이런 세가지 문제를 완할 때 사용할 수 있는 것이 **ID를 이용해서 다른 애그리거트를 참조**하는 것이다.*

## **ID를 이용해서 다른 애그리거트를 참조시 장점**

- ID 참조를 사용하면 모든 객체가 참조로 연결되지 않고 한 애그리거트에 속한 객체들만 참조로 연결된다.  ⇒ 경계를 명확히 하면서 물리적인 연결을 제거하기 때문에 모델의 복잡도를 낮춰준다.
- 애그리거트 간의 의존을 제거하므로 응집도를 높여준다.
- 구현 복잡도를 낮춰준다.
- 애그리거트별로 다른 구현 기술을 사용하는 것도 가능해진다.

```java
public class ChangeOrderService {
	@Transactional
	public void changeShippingInfo(OrderId id, ShippingInfo newShippingInfo, 
																boolean useNewShippingAddrAsMemberAddr) {
		Order order = orderRepository.findByUd(id);
		if(order == null) throw new OrderNotFoundException();
		order.changeShippingInfo(newShippingInfo);
		if (useNewShippingAddrAsMemberAddr) {
			//ID를 이용해서 참조하는 애그리거트를 구한다.
			Customer customer = customerRepository.findById(order.getOrderer().getCustomerId());
			customer.changeAddress(newShippingInfo.getAddress());
		}
	}
}
```

## ID를 이용한 참조와 조회성능

N+1 조회 문제는 더 많은 쿼리를 실행해서 전체 조회 속도가 느려지는 원인이 된다. ID 참조시 N+1 조회 문제를 방지하려면 전용 조회 쿼리를 사용하면 된다.

# 애글거트 간 집합 연관

애그리거트간 1:N 관계, M:N 연관에 대해 살펴보자.

# 애그리거트를 팩토리로 사용하기

애그리거트가 갖고 있는 데이터를 이용해서 다른 애그리거트를 생성해야 한다면 애그리거트에 팩토리 메서드를 구현하는 것을 고려해보자.